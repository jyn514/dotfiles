# TODO: work this into gitconfig somehow
git_reset_author() {
	git -c user.email="$1" rebase "$2" --reset-author -x 'git commit --amend --no-edit --reset-author'
}

is_jj_repo() {
	# don't try to save the working copy, in case that hits an error
	jj workspace root --ignore-working-copy >/dev/null 2>/dev/null
}

show_conflicts() {
	jj diff --from @-- --to @- $(jj resolve --list | awk '{print $1}') --git | grepdiff --output-matching=hunk '<<<<<<<' | less
}

HEAD() {
	if is_jj_repo; then
		jj git fetch && jj new -r 'trunk()'
	else
		git fetch --quiet origin && git switch --detach origin/HEAD "$@"
	fi
}

[ -x /usr/bin/lesspipe ] && {
	export LESSOPEN="| /usr/bin/lesspipe %s";
	export LESSCLOSE="/usr/bin/lesspipe %s %s";
}

v () { vim "$@"; }
# uppercase is bad and it should feel bad
r () { R "$@"; }

add_path () {
	PATH="$1:$PATH"
}

exists () { command -v "$1" >/dev/null 2>&1; }

if exists xdg-open; then
	open () { for f in "$@"; do xdg-open "$f"; done; }
fi

yts () { youtube_search "$@"; }

ytd () { yt-dlp "$@"; }

cls () { clear; }

mkcd () { mkdir -p "$@" && cd "$1"; }
mkdc () { mkcd "$@"; }

# follow symlinks by default
rg () { command rg -L "$@"; }
vrg () { rg --no-heading "$@"; }

b () { bacon "$@"; }
c () { cargo "$@"; }
g() { git "$@"; }
gl() { git l "$@"; }
gs() { git s "$@"; }
gits() { git s "$@"; }

# show human-readable dates with offsets by default
dmesg () { command dmesg -e "$@"; }

dc () { docker-compose "$@"; }
# this shadows a mailcap command, but I've never used mailcap in my life
compose () { docker-compose "$@"; }

whatismyip() {
	# https://unix.stackexchange.com/a/194136
	dig +short myip.opendns.com @resolver4.opendns.com
}

what_belongs () {
	if command -v dpkg > /dev/null; then
		dpkg -L "$@"
	elif command -v rpm > /dev/null; then
		rpm -ql "$@"
	else
		echo "no supported package manager found" >&2
	fi
}

what_runs () {
	for file in $(what_belongs "$@"); do
		[ -f "$file" ] && [ -x "$file" ] && echo "$file"
	done
}

what_package () {
	prog="$(realpath "$1")"; shift
	if command -v dpkg > /dev/null; then
		dpkg -S "$(command -v "$prog")" "$@"
	elif command -v rpm > /dev/null; then
		rpm -qf "$(command -v "$prog")" "$@"
	else
		echo "no supported package manager found" >&2
	fi
}

belongs () { what_belongs "$@"; }
runs () { what_runs "$@"; }
package () { what_package "$@"; }

exa () { command exa --git "$@"; }

# don't replace crontab without warning
if crontab -i -l >/dev/null 2>/dev/null; then
  crontab () { command crontab -i "$@"; }
fi

# show a makefile as a dependency graph
visualize () {
	command -v makefile2graph > /dev/null || { echo "makefile2graph not found"; return 1; }
	command -v dot > /dev/null || { echo "dot not found"; return 1; }
	command -v xdot > /dev/null || { echo "xdot not found"; return 1; }
	makefile2graph | dot | xdot /dev/stdin
}

# don't show copyright every time (super annoying)
gdb () { command gdb -q "$@"; }

# for use with a makefile in the current directory
tasks () {
	make -npRr | \
	awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ "^[#.]") {print $$1}}' | \
	grep -v "^[#$(printf '\t')]" | sed 's/:.*$//'
}

# same as tasks, but show body of recipe
recipies () {
	make -npRr | \
	awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ "^[#.]") {print $$1}}' | \
	grep -v "^#"
}

# launch and disown a command
background () {
	if [ $# -eq 0 ]
		then echo usage: background '<command>'
		return 1
	else
		"$@" &
		disown
	fi
}

show_time () { watch -n 1 -t date; }

# zip recursively by default
zip () { command zip -r "$@"; }

powershell () { pwsh "$@"; }

save_power () { sudo powertop --auto-tune; }

clean_shell () {
    env -i HOME="$HOME" TERM="$TERM" "$(command -v bash)" --noprofile --rcfile /etc/profile
}

if ls -G --color=auto --ignore=__pycache__ >/dev/null 2>/dev/null; then
    ls () { command ls -G --color=auto --ignore=__pycache__ "$@"; }
fi

ip() { command ip --color "$@"; }

purge_removed () {
	dpkg -l | awk '/^rc/ {print $2}' | xargs sudo dpkg --purge
}

purge () { sudo apt autoremove --purge "$@"; }

restart () { shutdown -r now; }

sl () { ls "$@"; }
ll () { ls -l "$@"; }
la () { ls -A "$@"; }
l () { ls -F "$@"; }

webpaste () {
   nc termbin.com 9999
}

ascii () { man ascii; }

# files on disk
file_count () { locate -S; }

excuse () {
	telnet towel.blinkenlights.nl 666 2>/dev/null | tail -2 | cowsay -f dragon
}

status () {
	if is_jj_repo; then
		jj status
	elif [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = true ]; then
		git s
	else
		l
	fi
}
s() { status "$@"; }

dad () { curl https://icanhazdadjoke.com && echo; }

weather () { curl wttr.in/; }
wttr () { weather; }

pytime () { python -m timeit; }

ubuntu () { docker run -it ubuntu; }

pip_upgrade_all () {
	pip list | awk '{print $1}' | tail --lines=+3 | xargs pip install -U "$@"
}

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alert () {
	notify-send --urgency=low \
	"$([ $? = 0 ] && echo terminal || echo error)" \
	"$(history | tail -1 | sed -e 's/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//')"
}

# https://stackoverflow.com/questions/9679932
npm_exec () {
	COMMAND="npm bin"
	if [ $# -gt 0 ] && [ "$1" = "-g" ]
		then COMMAND="$COMMAND --global"
		shift
	fi
	PATH="$($COMMAND):$PATH" "$@";
}

fork_github() {
	case $1 in
		https://*|ssh://*) URL=$1;;
		*) URL=https://github.com/$1;;
	esac

	# set -x
	# https://stackoverflow.com/a/13840631
	DIR=$(echo "$URL" | sed -e 's|/$||' -e 's|:*/*\.git$||' -e 's|.*[/:]||g')
	git clone $URL $DIR

	builtin cd $DIR
	git remote add personal git@github.com:jyn514/$DIR.git
	git remote set-url --push origin git@github.com:jyn514/$DIR.git
	echo $DIR
}

# modified from https://github.com/charlesdaniels/dotfiles/blob/master/overlay/.zsh/zsh-ocd.zsh
# when run without arguments, print all directories where there's an open file handle
# for the programs listed in FILTER_REGEX (currently bash and vim)
# when run with arguments,
#  if there is a unique match for the argument as a extended regex, change to that directory
#  else, print all directories which did match
ocd () {
	OCD_BLACKLIST_REGEX='(^[/]lib)|(^[/]usr[/]lib)|(^[/]$)|(^[/]var)|(^[/]bin)|(^[/]usr[/]share)|(^[/]usr[/]bin)|(^[/]usr[/]local[/]bin)|(^[/]tmp)|(^[/]dev)|(share[/]fonts)|([/][.]cache[/])|([.]swp$)|(^[/]run)'
	OCD_FILTER_REGEX='(^(ba|z)?sh)|(^[gn]?vim)'
	OCD_FILE_LIST=""

	if [ -x "$(command -v lsof 2>/dev/null)" ] ; then
		OCD_FILE_LIST="$(lsof -u $(whoami) | grep -E $OCD_FILTER_REGEX | awk '{print($9);}' | grep -P '^[/]' | grep -P -v $OCD_BLACKLIST_REGEX | sort | uniq)"
	fi

	# make sure everything in the file list is a directory
	OCD_DIRLIST=""
	for ocd_fpath in $(echo $OCD_FILE_LIST | tr '\n' ' ') ; do
		if [ -f "$ocd_fpath" ] ; then
			ocd_fpath="$(dirname "$ocd_fpath")"
		fi
		OCD_DIRLIST="$ocd_fpath
$OCD_DIRLIST"
	done

	OCD_TARGET="$(echo "$OCD_DIRLIST" | sort | uniq | grep -v -P '^$' | grep -P "$1")"
	if [ "$(echo "$OCD_TARGET" | wc -l)" -eq 1 ] ; then
		cd "$OCD_TARGET"
	else
		echo "$OCD_TARGET"
	fi
}


GITHUB='https://github.com/'
MY_GITHUB='https://github.com/jyn514'
SRC="/usr/local/src"
DOTFILES="$(dirname "$(dirname "$(realpath ~/.profile)")")"

if [ -f ~/.local/profile ]; then
	. ~/.local/profile
fi

if [ -d ~/.local/bin ]; then
	add_path "$HOME/.local/bin"
fi

if exists code; then
	export EDITOR="code --wait"
	export VISUAL="code --wait"
else
	export EDITOR=vim
	export VISUAL=vim
fi

export ENV="$HOME/.profile"
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
export JUPYTER_CONFIG_DIR=~/.config/jupyter
export JAVA_HOME=/usr/lib/jvm/default-java
export BAT_TABS=8
export BAT_STYLE=numbers
export GOPATH=~/.local/lib/go
export GOBIN="$GOPATH/bin"
export RUSTUP_HOME="$HOME/.local/lib/rustup"
export CARGO_HOME="$HOME/.local/lib/cargo"
export CARGO_TARGET_DIR="$CARGO_HOME/target"
export CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse
export CARGO_MOMMYS_MOODS=ominous
# git treats `diff.external` extremely poorly; there's no way to unset it temporarily because `-c diff.external` tries to run an empty program.
# instead, set this through an external env variable so we can unset it with `env -u`.
export GIT_EXTERNAL_DIFF=difft

# Delta is bad at doing version detection.
# https://github.com/dandavison/delta/issues/488
if ! less --version >/dev/null 2>&1; then
  export GIT_PAGER=less
fi

export MAKEFLAGS='-j4'
# for http://overthewire.org
# Honestly if you want to use this I don't really mind
export OTWUSERDIR="/d/SERPjdbrX3w3tsyXQQt0"

# bash shell and haven't sourced bashrc
if [ "$BASH_VERSION" ] && [ -n "$BASH_PROFILE_READ" ]; then
	. ~/.bashrc
fi

awawa_handler() {
	{ if exists figlet; then figlet "$1!!!"; else echo "$1!!!"; fi
        } | cowsay -f "$DOTFILES"/lib/angel.cow -n
}

# really this is a bash/zsh thing, but sh just ignores this function if it doesn't support it
command_not_found_handle() {
	case "$1" in
		# awawawa!
		awa|awawa*) awawa_handler "$@"; return 0;;
		# check if we forgot to put a space between `g` and the git subcommand, but not for `gh`, which is its own command
		gh) ;;
		g*) sub=${1#*g}
		if git --list-cmds=list-mainporcelain,others,nohelpers,alias,config | grep "^$sub$" --quiet; then
			shift
			git "$sub" "$@"
			return $?
		fi;;
		# this is kinda cursed
		cc) ;;
		c*) sub=${1#*c}
		if cargo --list | awk '{print $1}' | grep "^$sub$" --quiet; then
			shift
			cargo "$sub" "$@"
			return $?
		fi;;
	esac

	# this looks weird because it uses absolute paths. we're the command-not-found handler, we don't want to call ourselves indefinitely.
	if CNF=$(command -v command-not-found 2>/dev/null); then
		$CNF -- "$1"
		return $?
	# TODO: this is slow, consider https://github.com/oneElectron/brew-command-not-found
	elif BREW=$(command -v brew 2>/dev/null) && CMD=$($BREW which-formula --explain "$1") && [ "$CMD" ]; then
		echo "$CMD"
		return 127
	else
		printf "%s: command not found\n" "$1" >&2
		return 127
	fi
}
command_not_found_handler() { command_not_found_handle "$@"; }

# zsh uses `{%` instead of `\01`: https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html#Visual-effects
if [ -n "$ZSH_VERSION" ]; then
	ansi_escape () { command printf "%%{$1%%}"; }
else
	ansi_escape () { command printf "\01$1\02"; }
fi

PROMPT_DIRTRIM=2

display_pwd () {
	# reimplementation of PROMPT_DIRTRIM in pure shell
	# is this good
	# do you like this

	# 1. substitute $HOME with ~
	# 2. first group: match first character (~ or /)
	# 3. anything in the middle
	# 4. second group: last $PROMPT_DIRTRIM directories
	pwd | sed "s#$HOME#~#; s#^\(~\?/\).*\(\(/[^/]\+\)\{$PROMPT_DIRTRIM\}\)#\1...\2#"
}

RED="$(ansi_escape "\033[0;31m")"
GREEN="$(ansi_escape "\033[0;32m")"
YELLOW="$(ansi_escape "\033[0;33m")"
BLUE="$(ansi_escape "\033[0;34m")"
RESET="$(ansi_escape "\033[0;0m")"

jj_info() {
	# jj doesn't really use branches, so we don't print anything other than whether the workspace is modified
	# if there are branches, this is probably a co-located git repo, so `git_info` will just work without having to call this function.

	# NOTE: as a side effect, this saves the working copy :3
	# if there's an error here, we'll see it because we don't redirect stderr.
	if [ $(jj diff --summary | wc -l) = 0 ]; then
		printf %s "$GREEN"
	else
		printf %s "$RED"
	fi
	printf ' jj'
}

git_info() {
  # if this isn't a git repo, we can't show anything useful
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		if is_jj_repo; then jj_info; fi
		return
	else
		printf ' '
	fi

	# if we have local modifications, show the status in red
	if git diff-index --quiet HEAD -- 2>/dev/null; then
		printf %s "$GREEN"
	# weird edge case: this could be a repo with no commits at all
	elif [ "$(find . -maxdepth 1 | wc -l)" -le 2 ]; then
		printf %s "$GREEN"
	else
		printf %s "$RED"
	fi

	# if HEAD is on a branch, point to that branch
	if git symbolic-ref --short HEAD 2>/dev/null; then
		return
	fi

	# next, see if this is a tag
	t=$(git tag --points-at HEAD)
	if [ "$t" ]; then
		echo "$t"
		return
	fi

	# see if this is a remote branch
	# note this prioritizes origin/HEAD over origin/main
	r=$(git show-ref | grep ^"$(git rev-parse @).* refs/remotes" | grep -v '/gh-readonly-queue/' | head -n1 | sed 's#.* refs/remotes/##')
	if [ "$r" ]; then
		echo "$r"
		return
	fi

	# see if this is a detached local branch
	l=$(git show-ref | grep ^"$(git rev-parse @).* refs/heads" | head -n1 | sed 's#.* refs/heads/##')
	if [ "$l" ]; then
		echo "(detached at $l)"
		return
	fi

	# give up
	echo "(detached HEAD)"
}

prompt_command() {
	# save the status code before anything else; commands we execute in PS1 will overwrite it
	last_status=$?
	now=$(date +%s.%N)
	if [ -e ~/.cache/$$-start ]; then
		read start_time < ~/.cache/$$-start
		elapsed=$(awk "BEGIN {printf \"%.3f\", $now - $start_time}")
		printf %s "$elapsed" > ~/.cache/$$-elapsed
		# delete this file now, so if we hit <ENTER> without running a command it doesn't show an elapsed time
		rm ~/.cache/$$-start
	fi
	printf %s "($YELLOW$(basename -- "${ZSH_ARGZERO:-$0}")$RESET@$GREEN"; hostname | tr -d '\n'
	[ "$(id -u)" -eq 0 ] && printf %s "$RESET,${RED}root"
	printf %s "$RESET) $BLUE"
	display_pwd | tr -d '\n'
	git_info | tr -d '\n'
	# show the time the last command took to execute
	if [ "$start_time" ]; then
		printf %s "$RESET"
		time="[+$elapsed]"
		printf "\033[1000C"
		printf "\033[$(printf %s "$time" | wc -c)D$time"
	fi
	# bash appears to strip trailing newlines from PS1, so we need something to come *after* the newline
	printf "\n%s" "$RESET"
	# vscode already shows the cursor indented a bit, as well as the status from the last command
	if ! [ "$VSCODE_SHELL_INTEGRATION" = 1 ]; then
		if [ "$last_status" = 0 ]; then printf %s "$GREEN"; else printf %s "$RED"; fi
		printf ';%s ' "$RESET"
	fi
}

preexec() {
  # on executing the command, overwrite `;` with the timestamp
  printf "\033[2A"
  printf "\033[1000C"
  # show the elapsed time
  if [ -e ~/.cache/$$-elapsed ]; then
	read elapsed < ~/.cache/$$-elapsed
	rm ~/.cache/$$-elapsed
	s="[+$elapsed|$(date +%T | tr -d '\n')]"
  else
	s="[$(date +%T | tr -d '\n')]"
  fi
  len=$(printf %s "$s" | wc -c)
  printf "\033[${len}D%s\n\n\033[0;0m" "$s"
  date +%s.%N | tr -d '\n' > ~/.cache/$$-start
}

trap 'rm -f ~/.cache/$$-start ~/.cache/$$-elapsed' EXIT

PS1='$(prompt_command)'
PS0='$(preexec)'

add_path "$(dirname "$(dirname "$(realpath ~/.profile)")")/bin"
add_path "$CARGO_HOME"/bin
add_path ~/.local/bin

if ! [ "$SSH_AUTH_SOCK" ] && exists keychain; then
	eval `keychain --quiet --eval --agents ssh`
fi

case "$-" in
	*i*) status; stty -ixon;;
	*)	;;
esac
