# vim: set ft=sh:

# do this even for non-interactive shells so `mosh home` works even if we're not already in a WSL session
exists () { command -v "$1" >/dev/null 2>&1; }
if ! [ "$SSH_AUTH_SOCK" ] && exists keychain; then
	eval "$(keychain --quiet --eval --agents ssh)"
	. ~/.keychain/"$(hostname | tr -d '\n')"-sh
fi

DOTFILES=$(dirname "$(realpath ~/.profile)")/..

add_path () {
	for p in "$@"; do
		if ! echo "$PATH" | grep -F "(^|:)$p(:|$)" >/dev/null 2>&1; then
			PATH="$p:$PATH"
		fi
	done
}

add_path_if_present() {
	if [ -d "$1" ]; then
		add_path "$1"
	fi
}

if [ -f ~/.local/profile ]; then
	. ~/.local/profile
fi

# note: the order is important, the latest addition takes precedence
# wtf ubuntu
if ! exists cowsay && [ -e /usr/games/cowsay ]; then
	add_path /usr/games
fi
if exists snap && snap_bin=$(snap debug paths | grep '^SNAPD_BIN='); then
	eval "$snap_bin"
	add_path "$SNAPD_BIN"
	unset snap_bin
fi

. "$DOTFILES/lib/paths.sh"

if exists nvim; then
	export EDITOR=editor-hax
	export LESSEDIT='%E %g?lm\:%lm'
	# julia has AWFUL defaults and doesn't wait for the editor to exit if it doesn't recognize it
	# https://github.com/JuliaLang/julia/blob/083bd8f687bb2a0608a1b0b4c99f811eecb56b3e/stdlib/InteractiveUtils/src/editless.jl#L49
	export JULIA_EDITOR=hx-hax  
else
	export EDITOR=vi
	export JULIA_EDITOR=open
fi
export VISUAL=$EDITOR

if [ -x /home/linuxbrew/.linuxbrew/bin/brew ]; then
	eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv sh)"
fi

case "$-" in
	*i*) ;;
	*)	return 0;;
esac

if [ -n "$BASH_VERSION" ] && [ -z "$BASH_PROFILE_READ" ]; then
	. ~/.bashrc
fi
if [ -n "$ZSH_VERSION" ] && [ -z "$ZSH_PROFILE_READ" ]; then
	. ${ZDOTDIR:-$HOME}/.zshrc
fi

. "$DOTFILES/lib/lib.sh"
. "$DOTFILES/bin/show-status"
if [ -d "$NVM_DIR" ]; then
	add_path "$NVM_DIR/versions/node/"v*/bin
	nvm() {
		unset -f nvm
		. "$NVM_DIR/nvm.sh"
		nvm "$@"
	}
fi

# set up env

. "$DOTFILES/lib/env.sh"
export GPG_TTY=$(tty)

# set up aliases

# https://www.etalabs.net/sh_tricks.html#:~:text=Reading%20input%20line%2Dby%2Dline
while IFS= read -r alias; do
	name=${alias%=*}
	expn=${alias#*=}
	alias "$name"="$expn"
done << EOF
$(grep -Ev '^(#|$)' "$DOTFILES/lib/abbr.txt")
EOF

# fish handles these with a regex
alias ...=../..
alias ....=../../..
alias .....=../../../..

# TODO: most of these should just be in bin

# TODO: work this into gitconfig somehow
git_reset_author() {
	git -c user.email="$1" rebase "$2" --reset-author -x 'git commit --amend --no-edit --reset-author'
}

show_conflicts() {
	jj diff --from @-- --to @- "$(jj resolve --list | awk '{print $1}')" --git | grepdiff --output-matching=hunk '<<<<<<<' | less
}

HEAD() {
	if is_jj_repo; then
		jj git fetch && jj new -r 'trunk()'
	else
		git fetch --quiet origin && git switch --detach origin/HEAD "$@"
	fi
}

[ -x /usr/bin/lesspipe ] && {
	export LESSOPEN="| /usr/bin/lesspipe %s";
	export LESSCLOSE="/usr/bin/lesspipe %s %s";
}

mkcd () { mkdir -p "$@" && cd "$1"; }

# follow symlinks by default
rg () { command rg -z -L --no-heading "$@"; }

# note: the `cd` makes tmux open helix in the right working directory
b () {
	builtin cd "$(cargo metadata --format-version 1| jq .workspace_root -r)" && bacon "$@"
}

whatismyip() {
	# https://unix.stackexchange.com/a/194136
	dig +short myip.opendns.com @resolver4.opendns.com
}

what_belongs () {
	if command -v dpkg > /dev/null; then
		dpkg -L "$@"
	elif command -v rpm > /dev/null; then
		rpm -ql "$@"
	else
		echo "no supported package manager found" >&2
	fi
}

what_runs () {
	for file in $(what_belongs "$@"); do
		[ -f "$file" ] && [ -x "$file" ] && echo "$file"
	done
}

what_package () {
	prog="$(realpath "$1")"; shift
	if command -v dpkg > /dev/null; then
		dpkg -S "$(command -v "$prog")" "$@"
	elif command -v rpm > /dev/null; then
		rpm -qf "$(command -v "$prog")" "$@"
	else
		echo "no supported package manager found" >&2
	fi
}

# don't replace crontab without warning
crontab() {
	if command crontab -i -l >/dev/null 2>/dev/null; then
		crontab () { command crontab -i "$@"; }
	else
		crontab () { command crontab "$@"; }
	fi
	crontab "$@"
}

# show a makefile as a dependency graph
visualize () {
	command -v makefile2graph > /dev/null || { echo "makefile2graph not found"; return 1; }
	command -v dot > /dev/null || { echo "dot not found"; return 1; }
	command -v xdot > /dev/null || { echo "xdot not found"; return 1; }
	makefile2graph | dot | xdot /dev/stdin
}

# for use with a makefile in the current directory
tasks () {
	make -npRr | \
	awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ "^[#.]") {print $$1}}' | \
	grep -v "^[#$(printf '\t')]" | sed 's/:.*$//'
}

# same as tasks, but show body of recipe
recipies () {
	make -npRr | \
	awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ "^[#.]") {print $$1}}' | \
	grep -v "^#"
}

# launch and disown a command
background () {
	if [ $# -eq 0 ]
		then echo usage: background '<command>'
		return 1
	else
		"$@" &
		disown
	fi
}

pure_shell() {
   env -i HOME="$HOME" TERM="$TERM" PS1='; ' HISTSIZE=-1 HISTFILE= bash --norc --noprofile
}

# doesn't show broken symlinks; doesn't use hyperlinks
# if exists fls; then
# 	ls() { fls "$@"; }
# else
	ls () {
		if command ls --hyperlink=auto --color=auto --ignore=__pycache__ >/dev/null 2>/dev/null; then
			ls () { command ls --hyperlink=auto --color=auto --ignore=__pycache__ "$@"; }
		else
			ls() { command ls "$@"; }
		fi
		ls "$@"
	}
# fi

purge_removed () {
	dpkg -l | awk '/^rc/ {print $2}' | xargs sudo dpkg --purge
}

excuse () {
	telnet towel.blinkenlights.nl 666 2>/dev/null | tail -2 | cowsay -f dragon
}

dad () { curl https://icanhazdadjoke.com && echo; }

pip_upgrade_all () {
	pip list | awk '{print $1}' | tail --lines=+3 | xargs pip install -U "$@"
}

fork_github() {
	dir=$(command fork-github "$@")
	builtin cd "$dir" || return
	echo "$dir"
}

GITHUB='https://github.com/'
MY_GITHUB='https://github.com/jyn514'
SRC="/usr/local/src"

if [ "$DISPLAY" ]; then
	if is_wsl; then
		MANOPT=--html=$DOTFILES/bin/firefox.sh
		export MANOPT
	else
		# you know what unix if you can't come up with working hyperlinks in 50 years then fuck you too
		man() {
			local section
			case "$1" in
				-*) command man "$@"; return;;
				*) if rg '^SECTION' /etc/manpath.config | \
				      awk 'BEGIN { arg="'"$1"'"; code=1 } {for (i=2; i<=NF; i++) if($i == arg) { code=0 }} END { exit code }'
				   then
					    section=$1
							shift
					 fi
			esac
			if [ $# -ne 1 ]; then
				# oops something went wrong
				command man "$section" "$@"
				return
			fi

			check() {
				[ 200 = "$(curl -I -m 1 -s -o /dev/null -w "%{http_code}" "$@")" ]
			}

			url=https://man.openbsd.org/$1${section:+.$section}
			if check "$url"; then
				xdg-open "$url"
				return
			fi
			if ! [ "$section" ]; then
				section=$(man -k "$1" | rg "^$1" | head -n1 | awk '{print $2}' | tr -d '()')
			fi
			url=https://manpages.ubuntu.com/manpages/$(lsb_release -cs)/man$section/$1.$section.html
			if check "$url"; then
				xdg-open "$url"
				return
			fi
			command man "$section" "$@"
		}
	fi
fi

# Delta is bad at doing version detection.
# https://github.com/dandavison/delta/issues/488
if ! less --version >/dev/null 2>&1; then
  export GIT_PAGER=less
fi

awawa_handler() {
	{ if exists figlet; then figlet "$1!!!"; else echo "$1!!!"; fi
        } | cowsay -f "$DOTFILES"/lib/angel.cow -n
}

default_command_not_found() {
	printf "%s: command not found\n" "$1" >&2

	help=
	exists command-not-found && help+=$(printf "\n%s" "command-not-found -- \"$1\"")
	exists dnf && help+=$(printf "\n  %s" "dnf --cacheonly repoquery --quiet --whatprovides \"*/bin/$1\"")
	exists brew && help+=$(printf "\n  %s" "brew which-formula --explain --skip-update \"$1\"")

	echo "  consider searching for it with one of:"
	printf %s "  suggest-missing-command \"$1\""
	if [ -n "$help" ]; then
		echo "$help"
	fi
	echo

	return 127
}

# really this is a bash/zsh thing, but sh just ignores this function if it doesn't support it
command_not_found_handle() {
	# short-circuit if we're still starting up
	if [ -n "$RPS1" ]; then
		default_command_not_found "$@"
		return $?
	fi
	case "$1" in
		# awawawa!
		awa|awawa*) awawa_handler "$@"; return 0;;
		# check if we forgot to put a space between `g` and the git subcommand, but not for `gh`, which is its own command
		gh) ;;
		g*) sub=${1#*g}
		if git --list-cmds=list-mainporcelain,others,nohelpers,alias,config | grep "^$sub$" -q; then
			shift
			git "$sub" "$@"
			return $?
		fi;;
		# this is kinda cursed
		cc) ;;
		# lol, lmao
		cargo) ;;
		c) ;;
		c*) sub=${1#*c}
		if cargo --list | awk '{print $1}' | grep "^$sub$" -q; then
			shift
			cargo "$sub" "$@"
			return $?
		fi;;
	esac

	if SUGGEST=$(command -v suggest-missing-command 2>/dev/null); then
		timeout .1s "$SUGGEST" "$@"
	fi
	if ! [ $# = 123 ]; then
		default_command_not_found "$@"
	fi
}
command_not_found_handler() { command_not_found_handle "$@"; }

remember() {
	printf '\e]8;;%s\e\\%s\e]8;;\e\\\n' 'obsidian://open?vault=notes&file=global%20checklist' 'are you forgetting something?'
}

. "$DOTFILES/bin/prompt-command"

PS1='$(prompt_command "${ZSH_ARGZERO:-$0}")'
# also reset the cursor mode (https://stackoverflow.com/a/59728228)
PS0=$(printf '\e[2 q')

stty -ixon
remember
